{"version":3,"file":"llmExtract.js","sourceRoot":"","sources":["../../../../../src/scraper/scrapeURL/transformers/llmExtract.ts"],"names":[],"mappings":"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","sourcesContent":["import OpenAI from \"openai\";\nimport { encoding_for_model } from \"@dqbd/tiktoken\";\nimport { TiktokenModel } from \"@dqbd/tiktoken\";\nimport { Document, ExtractOptions } from \"../../../controllers/v1/types\";\nimport { Logger } from \"winston\";\nimport { EngineResultsTracker, Meta } from \"..\";\n\nconst maxTokens = 32000;\nconst modifier = 4;\n\nexport class LLMRefusalError extends Error {\n    public refusal: string;\n    public results: EngineResultsTracker | undefined;\n\n    constructor(refusal: string) {\n        super(\"LLM refused to extract the website's content\")\n        this.refusal = refusal;\n    }\n}\n\nfunction normalizeSchema(x: any): any {\n    if (typeof x !== \"object\" || x === null) return x;\n\n    if (x[\"$defs\"] !== null && typeof x[\"$defs\"] === \"object\") {\n        x[\"$defs\"] = Object.fromEntries(Object.entries(x[\"$defs\"]).map(([name, schema]) => [name, normalizeSchema(schema)]));\n    }\n\n    if (x && x.anyOf) {\n        x.anyOf = x.anyOf.map(x => normalizeSchema(x));\n    }\n\n    if (x && x.oneOf) {\n        x.oneOf = x.oneOf.map(x => normalizeSchema(x));\n    }\n\n    if (x && x.allOf) {\n        x.allOf = x.allOf.map(x => normalizeSchema(x));\n    }\n\n    if (x && x.not) {\n        x.not = normalizeSchema(x.not);\n    }\n\n    if (x && x.type === \"object\") {\n        return {\n            ...x,\n            properties: Object.fromEntries(Object.entries(x.properties).map(([k, v]) => [k, normalizeSchema(v)])),\n            required: Object.keys(x.properties),\n            additionalProperties: false,\n        }\n    } else if (x && x.type === \"array\") {\n        return {\n            ...x,\n            items: normalizeSchema(x.items),\n        }\n    } else {\n        return x;\n    }\n}\n\nexport async function generateOpenAICompletions(logger: Logger, options: ExtractOptions, markdown?: string, previousWarning?: string, isExtractEndpoint?: boolean): Promise<{ extract: any, numTokens: number, warning: string | undefined }> {\n    let extract: any;\n    let warning: string | undefined;\n\n    const openai = new OpenAI();\n    const model: TiktokenModel = (process.env.MODEL_NAME as TiktokenModel) ?? \"gpt-4o-mini\";\n\n    if (markdown === undefined) {\n        throw new Error(\"document.markdown is undefined -- this is unexpected\");\n    }\n\n    // count number of tokens\n    let numTokens = 0;\n    const encoder = encoding_for_model(model as TiktokenModel);\n    try {\n        // Encode the message into tokens\n        const tokens = encoder.encode(markdown);\n    \n        // Return the number of tokens\n        numTokens = tokens.length;\n    } catch (error) {\n        logger.warn(\"Calculating num tokens of string failed\", { error, markdown });\n\n        markdown = markdown.slice(0, maxTokens * modifier);\n\n        let w = \"Failed to derive number of LLM tokens the extraction might use -- the input has been automatically trimmed to the maximum number of tokens (\" + maxTokens + \") we support.\";\n        warning = previousWarning === undefined ? w : w + \" \" + previousWarning;\n    } finally {\n        // Free the encoder resources after use\n        encoder.free();\n    }\n\n    if (numTokens > maxTokens) {\n        // trim the document to the maximum number of tokens, tokens != characters\n        markdown = markdown.slice(0, maxTokens * modifier);\n\n        const w = \"The extraction content would have used more tokens (\" + numTokens + \") than the maximum we allow (\" + maxTokens + \"). -- the input has been automatically trimmed.\";\n        warning = previousWarning === undefined ? w : w + \" \" + previousWarning;\n    }\n\n    let schema = options.schema;\n    if (schema && schema.type === \"array\") {\n        schema = {\n            type: \"object\",\n            properties: {\n                items: options.schema,\n            },\n            required: [\"items\"],\n            additionalProperties: false,\n        };\n    } else if (schema && typeof schema === 'object' && !schema.type) {\n      schema = {\n          type: \"object\",\n          properties: Object.fromEntries(\n              Object.entries(schema).map(([key, value]) => [key, { type: value }])\n          ),\n          required: Object.keys(schema),\n          additionalProperties: false\n      };\n    }\n\n    schema = normalizeSchema(schema);\n\n    const jsonCompletion = await openai.beta.chat.completions.parse({\n        model,\n        temperature: 0,\n        messages: [\n            {\n                role: \"system\",\n                content: options.systemPrompt,\n            },\n            {\n                role: \"user\",\n                content: [{ type: \"text\", text: markdown }],\n            },\n            {\n                role: \"user\",\n                content: options.prompt !== undefined\n                    ? `Transform the above content into structured JSON output based on the following user request: ${options.prompt}`\n                    : \"Transform the above content into structured JSON output.\",\n            },\n        ],\n        response_format: options.schema ? {\n            type: \"json_schema\",\n            json_schema: {\n                name: \"websiteContent\",\n                schema: schema,\n                strict: true,\n            }\n        } : { type: \"json_object\" },\n    });\n\n    if (jsonCompletion.choices[0].message.refusal !== null) {\n        throw new LLMRefusalError(jsonCompletion.choices[0].message.refusal);\n    }\n\n    extract = jsonCompletion.choices[0].message.parsed;\n\n    if (extract === null && jsonCompletion.choices[0].message.content !== null) {\n        try {\n            if (!isExtractEndpoint) {\n                extract = JSON.parse(jsonCompletion.choices[0].message.content);\n            } else {\n                const extractData = JSON.parse(jsonCompletion.choices[0].message.content);\n                extract = extractData.data.extract;\n            }\n        } catch (e) {\n            logger.error(\"Failed to parse returned JSON, no schema specified.\", { error: e });\n            throw new LLMRefusalError(\"Failed to parse returned JSON. Please specify a schema in the extract object.\");\n        }\n    }\n\n    // If the users actually wants the items object, they can specify it as 'required' in the schema\n    // otherwise, we just return the items array\n    if (options.schema && options.schema.type === \"array\" && !schema?.required?.includes(\"items\")) {\n        extract = extract?.items;\n    }\n    return { extract, warning, numTokens };\n}\n\nexport async function performLLMExtract(meta: Meta, document: Document): Promise<Document> {\n    if (meta.options.formats.includes(\"extract\")) {\n        const { extract, warning } = await generateOpenAICompletions(\n          meta.logger.child({ method: \"performLLMExtract/generateOpenAICompletions\" }),\n          meta.options.extract!,\n          document.markdown,\n          document.warning,\n        );\n        document.extract = extract;\n        document.warning = warning;\n    }\n\n    return document;\n}\n"]}