{"version":3,"file":"downloadFile.js","sourceRoot":"","sources":["../../../../../../src/scraper/scrapeURL/engines/utils/downloadFile.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,gDAAwB;AACxB,4CAAoB;AACpB,qCAA4D;AAC5D,uCAA0C;AAC1C,mCAAkC;AAClC,+BAAkC;AAClC,+CAAiC;AAE1B,KAAK,UAAU,iBAAiB,CAAC,GAAW;IAI/C,MAAM,QAAQ,GAAG,MAAM,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,4DAA4D;IAC/F,OAAO;QACH,QAAQ;QACR,MAAM,EAAE,MAAM,CAAC,IAAI,CAAC,MAAM,QAAQ,CAAC,WAAW,EAAE,CAAC;KACpD,CAAC;AACN,CAAC;AATD,8CASC;AAEM,KAAK,UAAU,YAAY,CAAC,EAAU,EAAE,GAAW;IAItD,MAAM,YAAY,GAAG,cAAI,CAAC,IAAI,CAAC,YAAE,CAAC,MAAM,EAAE,EAAE,YAAY,EAAE,KAAK,IAAA,SAAI,GAAE,EAAE,CAAC,CAAC;IACzE,MAAM,aAAa,GAAG,IAAA,2BAAiB,EAAC,YAAY,CAAC,CAAC;IAEtD,4DAA4D;IAC5D,mCAAmC;IACnC,MAAM,QAAQ,GAAG,MAAM,MAAM,CAAC,KAAK,CAAC,GAAG,EAAE;QACrC,UAAU,EAAE,IAAI,MAAM,CAAC,KAAK,CAAC;YACzB,OAAO,EAAE;gBACL,kBAAkB,EAAE,KAAK;aAC5B;SACJ,CAAC;KACL,CAAC,CAAC;IAEH,uFAAuF;IACvF,IAAI,QAAQ,CAAC,IAAI,KAAK,IAAI,EAAE,CAAC;QACzB,MAAM,IAAI,mBAAW,CAAC,wBAAwB,EAAE,EAAE,KAAK,EAAE,EAAE,QAAQ,EAAE,EAAE,CAAC,CAAC;IAC7E,CAAC;IAED,QAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,iBAAQ,CAAC,KAAK,CAAC,aAAa,CAAC,CAAC,CAAC;IACpD,MAAM,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;QAClC,aAAa,CAAC,EAAE,CAAC,QAAQ,EAAE,GAAG,EAAE,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC;QAChD,aAAa,CAAC,EAAE,CAAC,OAAO,EAAE,CAAC,KAAK,EAAE,EAAE;YAChC,MAAM,CAAC,IAAI,mBAAW,CAAC,8BAA8B,EAAE,EAAE,KAAK,EAAE,EAAE,KAAK,EAAE,EAAE,CAAC,CAAC,CAAC;QAClF,CAAC,CAAC,CAAC;IACP,CAAC,CAAC,CAAA;IAEF,OAAO;QACH,QAAQ;QACR,YAAY;KACf,CAAC;AACN,CAAC;AAlCD,oCAkCC","sourcesContent":["import path from \"path\";\nimport os from \"os\";\nimport { createWriteStream, promises as fs } from \"node:fs\";\nimport { EngineError } from \"../../error\";\nimport { Writable } from \"stream\";\nimport { v4 as uuid } from \"uuid\";\nimport * as undici from \"undici\";\n\nexport async function fetchFileToBuffer(url: string): Promise<{\n    response: Response,\n    buffer: Buffer\n}> {\n    const response = await fetch(url); // TODO: maybe we could use tlsclient for this? for proxying\n    return {\n        response,\n        buffer: Buffer.from(await response.arrayBuffer()),\n    };\n}\n\nexport async function downloadFile(id: string, url: string): Promise<{\n    response: undici.Response\n    tempFilePath: string\n}> {\n    const tempFilePath = path.join(os.tmpdir(), `tempFile-${id}--${uuid()}`);\n    const tempFileWrite = createWriteStream(tempFilePath);\n\n    // TODO: maybe we could use tlsclient for this? for proxying\n    // use undici to ignore SSL for now\n    const response = await undici.fetch(url, {\n        dispatcher: new undici.Agent({\n            connect: {\n                rejectUnauthorized: false,\n            },\n        })\n    });\n\n    // This should never happen in the current state of JS (2024), but let's check anyways.\n    if (response.body === null) {\n        throw new EngineError(\"Response body was null\", { cause: { response } });\n    }\n\n    response.body.pipeTo(Writable.toWeb(tempFileWrite));\n    await new Promise((resolve, reject) => {\n        tempFileWrite.on(\"finish\", () => resolve(null));\n        tempFileWrite.on(\"error\", (error) => {\n            reject(new EngineError(\"Failed to write to temp file\", { cause: { error } }));\n        });\n    })\n\n    return {\n        response,\n        tempFilePath,\n    };\n}\n"]}