{"version":3,"file":"fetch.js","sourceRoot":"","sources":["../../../../../src/scraper/scrapeURL/lib/fetch.ts"],"names":[],"mappings":"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","sourcesContent":["import { Logger } from \"winston\";\nimport { z, ZodError } from \"zod\";\nimport { v4 as uuid } from \"uuid\";\nimport * as Sentry from \"@sentry/node\";\n\nexport type RobustFetchParams<Schema extends z.Schema<any>> = {\n    url: string;\n    logger: Logger,\n    method: \"GET\" | \"POST\" | \"DELETE\" | \"PUT\";\n    body?: any;\n    headers?: Record<string, string>;\n    schema?: Schema;\n    dontParseResponse?: boolean;\n    ignoreResponse?: boolean;\n    ignoreFailure?: boolean;\n    requestId?: string;\n    tryCount?: number;\n    tryCooldown?: number;\n};\n\nexport async function robustFetch<Schema extends z.Schema<any>, Output = z.infer<Schema>>({\n    url,\n    logger,\n    method = \"GET\",\n    body,\n    headers,\n    schema,\n    ignoreResponse = false,\n    ignoreFailure = false,\n    requestId = uuid(),\n    tryCount = 1,\n    tryCooldown,\n}: RobustFetchParams<Schema>): Promise<Output> {\n    const params = { url, logger, method, body, headers, schema, ignoreResponse, ignoreFailure, tryCount, tryCooldown };\n\n    let request: Response;\n    try {\n        request = await fetch(url, {\n            method,\n            headers: {\n                ...(body instanceof FormData\n                ? ({})\n                : body !== undefined ? ({\n                    \"Content-Type\": \"application/json\",\n                }) : {}),\n                ...(headers !== undefined ? headers : {}),\n            },\n            ...(body instanceof FormData ? ({\n                body,\n            }) : body !== undefined ? ({\n                body: JSON.stringify(body),\n            }) : {}),\n        });\n    } catch (error) {\n        if (!ignoreFailure) {\n            Sentry.captureException(error);\n            if (tryCount > 1) {\n                logger.debug(\"Request failed, trying \" + (tryCount - 1) + \" more times\", { params, error, requestId });\n                return await robustFetch({\n                    ...params,\n                    requestId,\n                    tryCount: tryCount - 1,\n                });\n            } else {\n                logger.debug(\"Request failed\", { params, error, requestId });\n                throw new Error(\"Request failed\", {\n                    cause: {\n                        params, requestId, error,\n                    },\n                });\n            }\n           \n        } else {\n            return null as Output;\n        }\n    }\n\n    if (ignoreResponse === true) {\n        return null as Output;\n    }\n\n    const response = {\n        status: request.status,\n        headers: request.headers,\n        body: await request.text(), // NOTE: can this throw an exception?\n    };\n\n    if (request.status >= 300) {\n        if (tryCount > 1) {\n            logger.debug(\"Request sent failure status, trying \" + (tryCount - 1) + \" more times\", { params, request, response, requestId });\n            if (tryCooldown !== undefined) {\n                await new Promise((resolve) => setTimeout(() => resolve(null), tryCooldown));\n            }\n            return await robustFetch({\n                ...params,\n                requestId,\n                tryCount: tryCount - 1,\n            });\n        } else {\n            logger.debug(\"Request sent failure status\", { params, request, response, requestId });\n            throw new Error(\"Request sent failure status\", {\n                cause: {\n                    params, request, response, requestId,\n                },\n            });\n        }\n    }\n\n    let data: Output;\n    try {\n        data = JSON.parse(response.body);\n    } catch (error) {\n        logger.debug(\"Request sent malformed JSON\", { params, request, response, requestId });\n        throw new Error(\"Request sent malformed JSON\", {\n            cause: {\n                params, request, response, requestId,\n            },\n        });\n    }\n\n    if (schema) {\n        try {\n            data = schema.parse(data);\n        } catch (error) {\n            if (error instanceof ZodError) {\n                logger.debug(\"Response does not match provided schema\", { params, request, response, requestId, error, schema });\n                throw new Error(\"Response does not match provided schema\", {\n                    cause: {\n                        params, request, response, requestId,\n                        error, schema,\n                    }\n                });\n            } else {\n                logger.debug(\"Parsing response with provided schema failed\", { params, request, response, requestId, error, schema });\n                throw new Error(\"Parsing response with provided schema failed\", {\n                    cause: {\n                        params, request, response, requestId,\n                        error, schema\n                    }\n                });\n            }\n        }\n    }\n\n    return data;\n}"]}