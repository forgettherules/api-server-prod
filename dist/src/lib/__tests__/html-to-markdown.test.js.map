{"version":3,"file":"html-to-markdown.test.js","sourceRoot":"","sources":["../../../../src/lib/__tests__/html-to-markdown.test.ts"],"names":[],"mappings":";;AAAA,0DAAoD;AAEpD,QAAQ,CAAC,eAAe,EAAE,GAAG,EAAE;IAC7B,EAAE,CAAC,kDAAkD,EAAE,KAAK,IAAI,EAAE;QAChE,MAAM,IAAI,GAAG,sBAAsB,CAAC;QACpC,MAAM,gBAAgB,GAAG,eAAe,CAAC;QACzC,MAAM,MAAM,CAAC,IAAA,gCAAa,EAAC,IAAI,CAAC,CAAC,CAAC,QAAQ,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC;IACpE,CAAC,CAAC,CAAC;IAEH,EAAE,CAAC,8DAA8D,EAAE,KAAK,IAAI,EAAE;QAC5E,MAAM,IAAI,GAAG,iFAAiF,CAAC;QAC/F,MAAM,gBAAgB,GAAG,sCAAsC,CAAC;QAChE,MAAM,MAAM,CAAC,IAAA,gCAAa,EAAC,IAAI,CAAC,CAAC,CAAC,QAAQ,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC;IACpE,CAAC,CAAC,CAAC;IAEH,EAAE,CAAC,gDAAgD,EAAE,KAAK,IAAI,EAAE;QAC9D,MAAM,IAAI,GAAG,EAAE,CAAC;QAChB,MAAM,gBAAgB,GAAG,EAAE,CAAC;QAC5B,MAAM,MAAM,CAAC,IAAA,gCAAa,EAAC,IAAI,CAAC,CAAC,CAAC,QAAQ,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC;IACpE,CAAC,CAAC,CAAC;IAEH,EAAE,CAAC,qCAAqC,EAAE,KAAK,IAAI,EAAE;QACnD,MAAM,IAAI,GAAG,IAAI,CAAC;QAClB,MAAM,gBAAgB,GAAG,EAAE,CAAC;QAC5B,MAAM,MAAM,CAAC,IAAA,gCAAa,EAAC,IAAI,CAAC,CAAC,CAAC,QAAQ,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC;IACpE,CAAC,CAAC,CAAC;IAEH,EAAE,CAAC,wDAAwD,EAAE,KAAK,IAAI,EAAE;QACtE,MAAM,YAAY,GAAG;YACnB,EAAE,IAAI,EAAE,uBAAuB,EAAE,QAAQ,EAAE,cAAc,EAAE;YAC3D,EAAE,IAAI,EAAE,gCAAgC,EAAE,QAAQ,EAAE,qBAAqB,EAAE;YAC3E,EAAE,IAAI,EAAE,4CAA4C,EAAE,QAAQ,EAAE,mBAAmB,EAAE;YACrF,EAAE,IAAI,EAAE,uDAAuD,EAAE,QAAQ,EAAE,gDAAgD,EAAE;SAC9H,CAAC;QAEF,KAAK,MAAM,EAAE,IAAI,EAAE,QAAQ,EAAE,IAAI,YAAY,EAAE,CAAC;YAC9C,MAAM,MAAM,CAAC,IAAA,gCAAa,EAAC,IAAI,CAAC,CAAC,CAAC,QAAQ,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;QAC5D,CAAC;IACH,CAAC,CAAC,CAAC;AACL,CAAC,CAAC,CAAC","sourcesContent":["import { parseMarkdown } from '../html-to-markdown';\n\ndescribe('parseMarkdown', () => {\n  it('should correctly convert simple HTML to Markdown', async () => {\n    const html = '<p>Hello, world!</p>';\n    const expectedMarkdown = 'Hello, world!';\n    await expect(parseMarkdown(html)).resolves.toBe(expectedMarkdown);\n  });\n\n  it('should convert complex HTML with nested elements to Markdown', async () => {\n    const html = '<div><p>Hello <strong>bold</strong> world!</p><ul><li>List item</li></ul></div>';\n    const expectedMarkdown = 'Hello **bold** world!\\n\\n- List item';\n    await expect(parseMarkdown(html)).resolves.toBe(expectedMarkdown);\n  });\n\n  it('should return empty string when input is empty', async () => {\n    const html = '';\n    const expectedMarkdown = '';\n    await expect(parseMarkdown(html)).resolves.toBe(expectedMarkdown);\n  });\n\n  it('should handle null input gracefully', async () => {\n    const html = null;\n    const expectedMarkdown = '';\n    await expect(parseMarkdown(html)).resolves.toBe(expectedMarkdown);\n  });\n\n  it('should handle various types of invalid HTML gracefully', async () => {\n    const invalidHtmls = [\n      { html: '<html><p>Unclosed tag', expected: 'Unclosed tag' },\n      { html: '<div><span>Missing closing div', expected: 'Missing closing div' },\n      { html: '<p><strong>Wrong nesting</em></strong></p>', expected: '**Wrong nesting**' },\n      { html: '<a href=\"http://example.com\">Link without closing tag', expected: '[Link without closing tag](http://example.com)' }\n    ];\n\n    for (const { html, expected } of invalidHtmls) {\n      await expect(parseMarkdown(html)).resolves.toBe(expected);\n    }\n  });\n});\n"]}