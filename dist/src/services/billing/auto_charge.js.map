{"version":3,"file":"auto_charge.js","sourceRoot":"","sources":["../../../../src/services/billing/auto_charge.ts"],"names":[],"mappings":"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","sourcesContent":["// Import necessary dependencies and types\nimport { AuthCreditUsageChunk } from \"../../controllers/v1/types\";\nimport { getACUC } from \"../../controllers/auth\";\nimport { redlock } from \"../redlock\";\nimport { supabase_service } from \"../supabase\";\nimport { createPaymentIntent } from \"./stripe\";\nimport { issueCredits } from \"./issue_credits\";\nimport { sendNotification } from \"../notification/email_notification\";\nimport { NotificationType } from \"../../types\";\nimport { deleteKey, getValue, setValue } from \"../redis\";\nimport { sendSlackWebhook } from \"../alerts/slack\";\nimport { logger } from \"../../lib/logger\";\n\n// Define the number of credits to be added during auto-recharge\nconst AUTO_RECHARGE_CREDITS = 1000;\nconst AUTO_RECHARGE_COOLDOWN = 300; // 5 minutes in seconds\n\n/**\n * Attempt to automatically charge a user's account when their credit balance falls below a threshold\n * @param chunk The user's current usage data\n * @param autoRechargeThreshold The credit threshold that triggers auto-recharge\n */\nexport async function autoCharge(\n  chunk: AuthCreditUsageChunk,\n  autoRechargeThreshold: number\n): Promise<{ success: boolean; message: string; remainingCredits: number; chunk: AuthCreditUsageChunk }> {\n  const resource = `auto-recharge:${chunk.team_id}`;\n  const cooldownKey = `auto-recharge-cooldown:${chunk.team_id}`;\n\n  try {\n    // Check if the team is in the cooldown period\n    // Another check to prevent race conditions, double charging - cool down of 5 minutes\n    const cooldownValue = await getValue(cooldownKey);\n    if (cooldownValue) {\n      logger.info(`Auto-recharge for team ${chunk.team_id} is in cooldown period`);\n      return {\n        success: false,\n        message: \"Auto-recharge is in cooldown period\",\n        remainingCredits: chunk.remaining_credits,\n        chunk,\n      };\n    }\n\n    // Use a distributed lock to prevent concurrent auto-charge attempts\n    return await redlock.using([resource], 5000, async (signal) : Promise<{ success: boolean; message: string; remainingCredits: number; chunk: AuthCreditUsageChunk }> => {\n      // Recheck the condition inside the lock to prevent race conditions\n      const updatedChunk = await getACUC(chunk.api_key, false, false);\n      if (\n        updatedChunk &&\n        updatedChunk.remaining_credits < autoRechargeThreshold\n      ) {\n        if (chunk.sub_user_id) {\n          // Fetch the customer's Stripe information\n          const { data: customer, error: customersError } =\n            await supabase_service\n              .from(\"customers\")\n              .select(\"id, stripe_customer_id\")\n              .eq(\"id\", chunk.sub_user_id)\n              .single();\n          \n          if (customersError) {\n            logger.error(`Error fetching customer data: ${customersError}`);\n            return {\n              success: false,\n              message: \"Error fetching customer data\",\n              remainingCredits: chunk.remaining_credits,\n              chunk,\n            };\n          }\n\n          if (customer && customer.stripe_customer_id) {\n            let issueCreditsSuccess = false;\n            // Attempt to create a payment intent\n            const paymentStatus = await createPaymentIntent(\n              chunk.team_id,\n              customer.stripe_customer_id\n            );\n            \n            // If payment is successful or requires further action, issue credits\n            if (\n              paymentStatus.return_status === \"succeeded\" ||\n              paymentStatus.return_status === \"requires_action\"\n            ) {\n              issueCreditsSuccess = await issueCredits(\n                chunk.team_id,\n                AUTO_RECHARGE_CREDITS\n              );\n            }\n\n            // Record the auto-recharge transaction\n            await supabase_service.from(\"auto_recharge_transactions\").insert({\n              team_id: chunk.team_id,\n              initial_payment_status: paymentStatus.return_status,\n              credits_issued: issueCreditsSuccess ? AUTO_RECHARGE_CREDITS : 0,\n              stripe_charge_id: paymentStatus.charge_id,\n            });\n\n            // Send a notification if credits were successfully issued\n            if (issueCreditsSuccess) {\n              await sendNotification(\n                chunk.team_id, \n                NotificationType.AUTO_RECHARGE_SUCCESS, \n                chunk.sub_current_period_start, \n                chunk.sub_current_period_end, \n                chunk, \n                true\n              );\n\n              // Set cooldown period\n              await setValue(cooldownKey, 'true', AUTO_RECHARGE_COOLDOWN);\n            } \n\n            // Reset ACUC cache to reflect the new credit balance\n            const cacheKeyACUC = `acuc_${chunk.api_key}`;\n            await deleteKey(cacheKeyACUC);\n            \n            if (process.env.SLACK_ADMIN_WEBHOOK_URL) {\n              const webhookCooldownKey = `webhook_cooldown_${chunk.team_id}`;\n              const isInCooldown = await getValue(webhookCooldownKey);\n              \n              if (!isInCooldown) {\n                sendSlackWebhook(\n                  `Auto-recharge: Team ${chunk.team_id}. ${AUTO_RECHARGE_CREDITS} credits added. Payment status: ${paymentStatus.return_status}.`,\n                  false,\n                  process.env.SLACK_ADMIN_WEBHOOK_URL\n                ).catch((error) => {\n                  logger.debug(`Error sending slack notification: ${error}`);\n                });\n                \n                // Set cooldown for 1 hour\n                await setValue(webhookCooldownKey, 'true', 60 * 60);\n              }\n            }\n            return {\n              success: true,\n              message: \"Auto-recharge successful\",\n              remainingCredits: chunk.remaining_credits + AUTO_RECHARGE_CREDITS,\n              chunk: {...chunk, remaining_credits: chunk.remaining_credits + AUTO_RECHARGE_CREDITS},\n            };\n          } else {\n            logger.error(\"No Stripe customer ID found for user\");\n            return {\n              success: false,\n              message: \"No Stripe customer ID found for user\",\n              remainingCredits: chunk.remaining_credits,\n              chunk,\n            };\n          }\n        } else {\n          logger.error(\"No sub_user_id found in chunk\");\n          return {\n            success: false,\n            message: \"No sub_user_id found in chunk\",\n            remainingCredits: chunk.remaining_credits,\n            chunk,\n          };\n        }\n      }\n      return {\n        success: false,\n        message: \"No need to auto-recharge\",\n        remainingCredits: chunk.remaining_credits,\n        chunk,\n      };\n\n    });\n  } catch (error) {\n    logger.error(`Failed to acquire lock for auto-recharge: ${error}`);\n    return {\n      success: false,\n      message: \"Failed to acquire lock for auto-recharge\",\n      remainingCredits: chunk.remaining_credits,\n      chunk,\n    };\n  }\n}\n"]}